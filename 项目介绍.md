## 直通设备迁移
我在VFIO设备直通热迁移项目中主导了核心功能开发：在英特尔E810网卡和IPU网卡驱动中部署了该功能，该方案通过VFIO PCI子系统迁移状态机制攻克了hypervisor无法获取VFIO 直通设备状态的难题。

技术难点在于：
1. VFIO设备的脏页追踪， 迁移过程中虚拟机内存会变，qemu通过KVM dirty page logging进行脏页追踪，在迭代迁移过程中只迁移被标脏的页。VFIO设备借助Intel 4th Xeon中新的IOMMU，其支持SSAD（second statge access/dirty），记录页面是否更改。通过IOMMU的脏页追踪，将网络断连时间降低了80%。
2.  E810网卡硬件限制：E810的网卡不支持直接写IO恢复硬件状态，使用了发送dummy package的方法恢复了脏页。该方案在linux内核社区引起的虚拟化专家的关注和热烈讨论，最终我们确定了在PF上下文中恢复VF状态的方案，并得到了linux社区的一致同意。

（热迁移的使用场景包括运维过程中，组件、服务需要升级；硬件错误、告警的时候主动触发迁移，避免系统crash。Kernel panic。）

关于技术方案落地：本项目先后在E810网卡和Intel IPU上开发了热迁移功能，在QEMU/KVM环境中进行了验证（高吞吐）。E810的代码upstream到linux内核社区。攥写白皮书。

[upstream patch](https://lore.kernel.org/netdev/?q=Lingyu+Liu)
[linux kernel thread](https://lore.kernel.org/netdev/9a613177-de20-49ac-88ce-421c37fe0c15@intel.com/)


## SIOV
另一个值得分享的项目是SIOV，我们实现了英特尔E810网卡和IPU网卡中的scalable iov功能。通过SIOV可以实现比VF更轻量级的设备ADI，不同于VF基于BDF号进行资源隔离，ADI是基于PASID对设备资源、DMA和中断隔离。
ADI的实现方面，我们使用了subfunction的方案，基于aux driver，在ICE模块初始化的时候注册aux driver，在其probe函数中初始化netdev ops。

在将ADI暴露到用户态方面，我们基于VFIO新的实现IOMMUFD，将ADI和PASID绑定，基于pasid实现了资源隔离。

#### auxiliary driver
Auxiliary Driver 是 Linux 内核中用于管理 ​辅助设备​（Auxiliary Device）的标准驱动框架。其核心作用如下：
**​设备绑定与通信**
实现辅助设备与主设备驱动之间的逻辑关联，通过 probe() 方法匹配并初始化辅助设备，通过 remove() 方法解除关联。

 - Auxiliary Driver 适用于以下典型场景：
​**(1) 主设备集成多个子功能模块**
- ​场景描述：
主设备（如 SoC、复杂外设）包含多个子功能模块（如温度传感器、时钟控制器、电源管理单元），这些模块需要独立驱动但又依赖主设备的存在。
- ​示例：
- 主设备驱动注册一个辅助温度传感器设备，由独立的 auxiliary_driver 管理。
- 主设备通过辅助设备扩展自身功能，而辅助设备无需单独出现在设备树中。

Auxiliary Driver 是一种轻量级的设备管理模型，适用于 ​功能模块化、硬件固定、主从依赖关系紧密 的场景。它通过标准化的接口和生命周期管理，为主设备驱动提供了灵活扩展功能的能力，同时保持辅助设备的独立性。

内核会在以下两种情况下调用 ​auxiliary driver 的 probe() 方法：

- 辅助设备注册时（主动触发）​
当主设备驱动通过 auxiliary_device_add() 向辅助总线注册一个新的辅助设备时，内核会执行以下步骤：
1. ​生成设备名：
辅助设备的完整名称为 <主驱动模块名>.<aux设备name>（例如 mlx5_core mlx5_mgmt）。
2. ​总线匹配：
内核遍历所有已注册的辅助驱动，检查其 id_table 中的 name 是否与辅助设备的名称匹配。
3. ​调用 probe()：
如果找到匹配的辅助驱动，则调用该驱动的 probe() 方法，传递 auxiliary_device 结构体和匹配的 auxiliary_device_id。

- 驱动动态加载时（被动触发）​
如果辅助设备已注册到总线上，但对应的辅助驱动尚未加载：
4. ​用户空间触发：
用户通过 insmod 加载辅助驱动模块时，内核会自动尝试绑定已存在的辅助设备。
5. ​内核自动匹配：
辅助驱动的 id_table 中的 name 必须与辅助设备的名称一致，此时内核会调用驱动的 probe() 方法。

## 网卡硬件报文协议解析
E810 pipeline的各个包处理阶段都是可以灵活配置的，parser可以通过parse graph解析出数据包的packet type, 为每个packet生成context metadata, 其对报文的解析深度可达**512B**，足够覆盖典型的隧道协议报文和各种复杂协议报文。DDP (dynamic device personalization) 可以针对特定应用场景进一步扩展E810 parser支持的协议。基于parser的结果，相应的profile会从报文中提取各个关键字段作为field vector用于后续Switch, ACL和Classification Filer的lookup key。E810 ACL基于TCAM (ternary content addressable memory) 可支持任意bit通配查找，flow director模块提供16K的规则容量，其匹配域可以覆盖隧道报文内外双层的各个关键字段。

